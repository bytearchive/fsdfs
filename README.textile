h1. fsdfs (f***ing simple distributed file system)

h2. Goals

fsdfs was originally developed at Jamendo.com to manage the distribution of millions of MP3/OGG files.

fsdfs aims to :
* make a single virtual filesystem accessible from several nodes
* be fully distributed (no single point of failure)
* automatically manage sharding/replication : adding a new node takes 10 seconds
* try to fill up its allowed disk quota to maximize redundancy
* be extensible via simple python code
* allow userland variables (like popularity) to boost a file's replication/redundancy level
* sit on top of any POSIX filesystem

h2. Roadmap

For simplicity, fsdfs 1.0 will have a master/slaves design (slaves being readable even if the master is down).
 
fsdfs 2.0 will remove the need of a master node, possibly using a DHT network like Kademlia. Code for 1.0 will
already be structured to make its implementation easy.


h2. Design for version 1.0

Each file has two important variables :
* Its target replication count N. (N=3 by default, can be customized per-file by a user-defined python function)
* Its current replication count K
 
The master has a list of all the nodes with their status, which includes :
* cpu/network load
* list of all the files replicated on the node
* free disk quota
 
The free disk quota will always tend to zero because each nodes tries to replicate as many files as it can. 
Hence, max(K-N) is a more interesting number for a node, because it measures the extent of "over-replication".
If max(K-N)>0, some copies on the server are not strictly necessary and could be deleted. 
If max(K-N)<=0, every copy is needed and the server should be considered "full".

The primary job of the master is to manage file replication, making sure target replications counts are
met or exceeded. In other words, it has to make min(K-N) accross all known files as high as it can.

The algorithm used is very simple : 
*# select the file having min(K-N)
*# choose a node :
   * not already having a copy of this file
   * not too loaded
   * with either free disk or a high max(K-N)
*# Have the file copied to this node (=> K++)
*# GOTO 1.

min(K-N) across all files is a good measure of the health and general disk usage of the filesystem. min(K-N) should be
positive, ideally greater than 1 (in which case all the files would have one more copy than the target replication count)

min(K-N) will naturally decrease when adding new files. min(K-N) becoming <1 or negative should be the signal that new nodes are needed.

h2. How to test

python tests/basic.py


h2. Todo

 - Disk quota
 - Admin command (watch replication)
 - Test crashes/disconnects/...
